<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Sam &#38; Max &#187; semver</title>
	<atom:link href="http://sametmax.com/tag/semver/feed/" rel="self" type="application/rss+xml" />
	<link>http://sametmax.com</link>
	<description>Du code, du cul</description>
	<lastBuildDate>Sat, 07 Nov 2015 10:56:13 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>http://wordpress.org/?v=4.1</generator>
	<item>
		<title>La notation de version SemVer 9</title>
		<link>http://sametmax.com/la-notation-de-version-semver/</link>
		<comments>http://sametmax.com/la-notation-de-version-semver/#comments</comments>
		<pubDate>Thu, 01 Jan 2015 06:52:58 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[semver]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=13068</guid>
		<description><![CDATA[Il y a des tas de manières d'indiquer la version d'un logiciel.

Ubuntu utilise l'année et le mois, à l'envers : la 14.04 indique une version sortie en avril 2014.

Avant la 1.2, angular utilisait les versions paires pour signifier la stabilité, et impaire pour l'instabilité.

Quelques projets utilisent des numéros de branche Git ou Svn.

Certains utilisent des noms du genre "kangourou-cosmique" pour marquer le coup.

Et d'autres mélangent plusieurs techniques.

En Python, la méthode recommandée est nommée SemVer, pour Semantic Versioning.]]></description>
				<content:encoded><![CDATA[<p>Il y a des tas de manières d&#8217;indiquer la version d&#8217;un logiciel.</p>
<p>Ubuntu utilise l&#8217;année et le mois, à l&#8217;envers : la 14.04 indique une version sortie en avril 2014.</p>
<p>Avant la 1.2, angular utilisait les versions paires pour signifier la stabilité, et impaire pour l&#8217;instabilité.</p>
<p>Quelques projets utilisent des numéros de branche Git ou Svn.</p>
<p>Certains utilisent des noms du genre &#8220;kangourou-cosmique&#8221; pour marquer le coup.</p>
<p>Et d&#8217;autres mélangent plusieurs techniques.</p>
<p>En Python, la méthode recommandée est nommée <a href="http://semver.org/">SemVer</a>, pour Semantic Versioning.</p>
<h2>Explications</h2>
<p>Tout est basé sur la notion d&#8217;API publique. Si vous ne vous souvenez pas de ce qu&#8217;est une API publique, <a href="http://sametmax.com/quest-ce-quune-api/">c&#8217;est par ici</a>.</p>
<p>Une bibliothèque versionnée avec SemVer doit clairement documenter toute son API publique pour dire : voici les bouts de codes que vous pouvez utiliser sans risque.</p>
<p>Beaucoup de devs ne font pas, tout comme on fait souvent du REST non pur, on fait souvent du SemVer non pur, mais je vous le dis sinon des puristes viendront jouer de la moustache en commentaires.</p>
<p>Le principe est simple : votre versioning est noté <code>x.y.z</code>, <code>x</code>, <code>y</code> et <code>z</code> étant des entiers positifs. A moins que le nombre soit <code>0</code>, aucun nombre ne doit commencer par <code>0</code>.</p>
<p>Le <code>x</code> représente une version majeure, qui introduit au moins un changement incompatible dans l&#8217;API publique.</p>
<p>Le <code>y</code> représente une version mineure, qui introduit au moins une nouvelle fonctionnalité dans l&#8217;API publique.</p>
<p>Le <code>z</code> représente une correction de bug ou un changement dans l&#8217;API privée.</p>
<p>Et c&#8217;est tout.</p>
<h2>En pratique</h2>
<p>Si vous réparez un bug, <code>z</code> augmente de <code>1</code>.</p>
<p>Ex : <code>1.3.4</code> devient <code>1.3.5</code></p>
<p>Si vous introduisez un nouveau paramètre optionnel, une fonction outil indépendante, un nouvel attribut public, <code>y</code> augmente de <code>1</code>, et <code>z</code> est remis à 0 :</p>
<p>Ex : <code>1.3.4</code> devient <code>1.4.0</code></p>
<p>Si une fonction retourne maintenant ne serait-ce qu&#8217;un tuple au lieu de précédemment une liste, <code>x</code> augmente de <code>1</code>, <code>y</code> et <code>z</code> sont remis à 0 :</p>
<p>Ex : <code>1.3.4</code> devient <code>2.0.0</code></p>
<h2>FAQ</h2>
<h3>Le numéro de version va monter très vite non ?</h3>
<p>On ne change le numéro de version que pour une version publiée. Si vous faites plein de petits changements mais que vous ne déclarez pas ce nouveau code comme la dernière version officielle, pas besoin de changer de version : vous êtes encore en développement.</p>
<p>N&#8217;oubliez pas aussi que c&#8217;est VOTRE job de vous assurez que votre programme reste compatible. Faites des adapters, des alias, introduisez les fonctionnalités de manière optionnelle, depréciation à l&#8217;avance&#8230; Il y a des moyens de faire ça proprement.</p>
<h3>C&#8217;est quand même over chiant pour une lib qui vient de sortir et que personne n&#8217;utilise, non ?</h3>
<p>Jusqu&#8217;à la version <code>1.0.0</code>, le SemVer ne s&#8217;applique pas. En <code>0.y.z</code>, on peut faire du freestyle.</p>
<h3>Mais si je suis en beta ?</h3>
<p>On peut signaler des informations supplémentaires en mettant un tiret après son versioning. Le style est libre mais la convention est généralement <code>x.y.z-status</code>. Ex : <code>1.3.3-alpha</code>, <code>1.3.3-beta</code>, <code>1.3.3-rc1</code>, etc.</p>
<h3>Attend, je fais une release parfaitement compatible, mais avec une fonction publique qui ne retourne plus <code>1</code> mais <code>True</code>, je vais pas bumper pour ça quand même ?</h3>
<p>Si. Si vous ne voulez pas le faire, mettez le dans une branche à part, et attendez une release plus grosse pour introduire ce changement.</p>
<h3>J&#8217;ai une correction de bug qui introduit une changement incompatible dans l&#8217;API publique, je fais quoi ?</h3>
<p>On bump. Ça n&#8217;arrive pas si souvent que ça qu&#8217;un bug change l&#8217;API publique, faut pas charrier.</p>
<h3>Ouais, genre tu le fais&#8230;</h3>
<p>Non, je ne fais pas du SemVer pur. Mais sur une lib qui est très utilisée, c&#8217;est un système indispensable. Si j&#8217;avais la responsabilité de pondre Django, ouais, je ferais du SemVer pur.</p>
<h3>Ok, je l&#8217;ai fais mais j&#8217;ai pas l&#8217;impression d&#8217;y gagner quoi que ce soit.</h3>
<p>Le bénéfice n&#8217;est pas pour l&#8217;auteur, mais pour les utilisateurs. Si un autre utilisateur à votre lib comme dépendance, il peut déclarer dans son fichier setup.py:</p>

<div class="wp_syntax"><table><tr><td class="code"><pre class="python" style="font-family:monospace;">requires<span style="color: #66cc66;">=</span><span style="color: black;">&#91;</span><span style="color: #483d8b;">'votrelib&gt;=1.3.1&lt;2.0.0'</span><span style="color: black;">&#93;</span></pre></td></tr></table></div>

<p>Ainsi il est certain que ça ne pétera pas si vous faites votre boulot correctement car la lib installée par pip sera toujours dans une version entre la 1.3.1 qu&#8217;il sait compatible, jusqu&#8217;à la 2.0.0 qui sera incompatible.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/la-notation-de-version-semver/feed/</wfw:commentRss>
		<slash:comments>9</slash:comments>
	<enclosure url="http://sametmax.com/wp-content/uploads/2015/01/1EoaX5x.gif" length="410254" type="image/jpg" />	</item>
	</channel>
</rss>
