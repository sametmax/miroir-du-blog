<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Droit de réponse au troll JS</title>
	<atom:link href="http://sametmax.com/droit-de-reponse-au-troll-js/feed/" rel="self" type="application/rss+xml" />
	<link>http://sametmax.com/droit-de-reponse-au-troll-js/</link>
	<description>Du code, du cul</description>
	<lastBuildDate>Sat, 07 Nov 2015 11:08:18 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>http://wordpress.org/?v=4.1</generator>
	<item>
		<title>By: josé</title>
		<link>http://sametmax.com/droit-de-reponse-au-troll-js/#comment-22050</link>
		<dc:creator><![CDATA[josé]]></dc:creator>
		<pubDate>Wed, 26 Mar 2014 16:12:54 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=9812#comment-22050</guid>
		<description><![CDATA[De toute façon, tous cela c&#039;est de la branlette, quand on a essayé node.js, le module asyncio de Python et bien on se dit qu&#039;on a bien fait d&#039;utiliser Go avec ses go routines et ses channels. Parque je ne sais pas si vous avez vu la gueule d&#039;asyncio ? C&#039;est entre le twisted et gevent. Je n&#039;aime pas du tout l&#039;API.]]></description>
		<content:encoded><![CDATA[<p>De toute façon, tous cela c&#8217;est de la branlette, quand on a essayé node.js, le module asyncio de Python et bien on se dit qu&#8217;on a bien fait d&#8217;utiliser Go avec ses go routines et ses channels. Parque je ne sais pas si vous avez vu la gueule d&#8217;asyncio ? C&#8217;est entre le twisted et gevent. Je n&#8217;aime pas du tout l&#8217;API.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Teocali</title>
		<link>http://sametmax.com/droit-de-reponse-au-troll-js/#comment-21587</link>
		<dc:creator><![CDATA[Teocali]]></dc:creator>
		<pubDate>Thu, 20 Mar 2014 07:56:11 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=9812#comment-21587</guid>
		<description><![CDATA[&lt;blockquote&gt;
    Ca m’empeche pas quand je vois une situation de merde d’essayer d’y remedier.
&lt;blockquote&gt;
Je ne t’ai pas beaucoup vu sur es-discuss et les autres mailing-lists de standards ;-)
&lt;/blockquote&gt;
&lt;/blockquote&gt;
Deja, je pense pas avoir les competences pour.
Ensuite, je developpe pas (plus) en JS, donc bon...
Enfin, sur mon temps libre, je prefere faire des trucs marrants que de meprendre la barbe avec d&#039;autre barbus. :P Genre developper mon script pour Codingame. D&#039;ailleurs, j&#039;y retourne, allez hop.]]></description>
		<content:encoded><![CDATA[<blockquote><p>
    Ca m’empeche pas quand je vois une situation de merde d’essayer d’y remedier.</p>
<blockquote><p>
Je ne t’ai pas beaucoup vu sur es-discuss et les autres mailing-lists de standards ;-)
</p></blockquote>
</blockquote>
<p>Deja, je pense pas avoir les competences pour.<br />
Ensuite, je developpe pas (plus) en JS, donc bon&#8230;<br />
Enfin, sur mon temps libre, je prefere faire des trucs marrants que de meprendre la barbe avec d&#8217;autre barbus. :P Genre developper mon script pour Codingame. D&#8217;ailleurs, j&#8217;y retourne, allez hop.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sam</title>
		<link>http://sametmax.com/droit-de-reponse-au-troll-js/#comment-21571</link>
		<dc:creator><![CDATA[Sam]]></dc:creator>
		<pubDate>Wed, 19 Mar 2014 22:34:57 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=9812#comment-21571</guid>
		<description><![CDATA[Merci David pour avoir instauré ce débat civilisé.]]></description>
		<content:encoded><![CDATA[<p>Merci David pour avoir instauré ce débat civilisé.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: David Bruant</title>
		<link>http://sametmax.com/droit-de-reponse-au-troll-js/#comment-21563</link>
		<dc:creator><![CDATA[David Bruant]]></dc:creator>
		<pubDate>Wed, 19 Mar 2014 20:10:06 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=9812#comment-21563</guid>
		<description><![CDATA[&lt;blockquote&gt;On pourrait résumer cette réponse (à part quelques points encore une fois) à “C’est pourri mais c’est normal et il faut faire avec”.&lt;/blockquote&gt;
Oui. Il n&#039;y a aucun débat sur le fait que JS est nul au niveau langage et même certaines API legacy genre le DOM (il y a un peu plus de débat sur d&#039;autres aspects notamment doc, écosystèmes, communautés, etc.)

&lt;blockquote&gt;Ca m’empeche pas quand je vois une situation de merde d’essayer d’y remedier.&lt;/blockquote&gt;
Je ne t&#039;ai pas beaucoup vu sur &lt;a href=&quot;https://mail.mozilla.org/pipermail/es-discuss/&quot; rel=&quot;nofollow&quot;&gt;es-discuss&lt;/a&gt; et les autres mailing-lists de standards ;-)


&lt;blockquote&gt;Mouahahahah. J’adore quand un spécialiste explique combien son outil est une grosse merde MAIS sic “il faut vivre avec” WTF! Le divorce c’est pas pour les chiens!&lt;/blockquote&gt;
C&#039;est un peu par erreur que je suis devenu spécialiste. &lt;a href=&quot;http://letrainde13h37.fr/47/dix-ans-pratique-javascript-paris/&quot; rel=&quot;nofollow&quot;&gt;Un peu comme Noëlie&lt;/a&gt;, mais pas tout pareil.
Il n&#039;y a pas de divorce. Le web est bâti sur le principe de backward-compatibilité (pour des raisons économiques) et les navigateurs ont des &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=957431#c20&quot; rel=&quot;nofollow&quot;&gt;dilemmes moraux&lt;/a&gt; dès qu&#039;ils vont peut-être casser un site web (le lien que je donne, c&#039;est vraiment juste un récent. Un parmi les 200 qu&#039;ils ont par jour), donc on ne peut pas améliorer le langage en enlevant les merdes. Donc, il faut apprendre à éviter les pièges.

&lt;blockquote&gt;La réponse est bonne, mais le mec en met des tartines pour justifier chaque point et comment faire avec/ne pas se faire mordre, ce qui confirme bien que c’est un mauvais langage :).&lt;/blockquote&gt;
Le mec te confirme :-) Mais on vit beaucoup mieux dès qu&#039;on a accepté le truc. C&#039;était un peu l&#039;objet de mon propos. Si on espère que JS soit bien, on ne se créé que des frustrations. Pour vivre heureux, il faut accepter passer la colline de frustration qui consiste à dire que le JS c&#039;est de la merde. En haut de cette colline, on peut alors réfléchir à comment on fait quand même des trucs, comment on se facilite la vie.



&lt;blockquote&gt;C’est même pas tant le fait que ça soit asynchrone qui prime mais le fait que ça soit non-bloquant&lt;/blockquote&gt;

Oui. Je me fatigue, je fais toujours la confusion.


&lt;blockquote&gt;Et si le JS avait gardé ses perfs d’origines, personne n’aurait levé les yeux sur node, asynchrone ou pas.&lt;/blockquote&gt;
Discutable, mais bon, on ne saura jamais.

&lt;blockquote&gt;Qui fait du Javascript avec Rhino ?&lt;/blockquote&gt;
Je soupçonne que Google App Script et ses .gs, ça soit du Rhino en-dessous (avec des APIs à eux en plus... avec I/O bloquante -_-#). Mais oui, JS sans Node.js n&#039;a pas grand sens.

&lt;blockquote&gt;L’article est là pour pointer à quel point le JS est un langage pourri. La raison pour laquelle il l’est (une dette technique colossale), ne change pas ce point. Et le prix à payer est très lourd. C’est toujours chiant de devoir se coltiner un boulet alors qu’il y a de meilleurs outils à côté.&lt;/blockquote&gt;
Rejoins-moi de l&#039;autre côté de la colline :-) Rester frustré ne sert à personne ;-)

&lt;blockquote&gt;Le problème de new n’est pas pour les experts, c’est pour les non experts. En effet, Javascript ne lève aucune erreur si on oubli new&lt;/blockquote&gt;

Il n&#039;y a pas de notion de constructeur dans le langage. Juste des fonctions et selon l&#039;envie du moment, on décrète que c&#039;est un constructeur ou pas et donc on décide de l’appeler avec new ou pas. Mais c&#039;est plus une convention entre développeurs. C&#039;est pour ça qu&#039;il ne lève pas d&#039;erreur.

&lt;blockquote&gt;Debugger en JS, et c’est encore plus vrai quand on est pas expert, est une vrai torture comparé à la concurrence.&lt;/blockquote&gt;

Oui. Mais ça s&#039;améliore dans les navigateurs. Node.js reste lamentable et c&#039;est assez triste. Mais tout le monde est au courant, donc des gens bossent sur la question.

&lt;blockquote&gt;C’est de pire en pire avec les nouveaux frameworks. Par exemple, j’utiliser Angularjs. Comme pour faire quelque chose de propre avec JS, ça demande pas mal d’abstraction et de magie, les messages d’erreurs sont incompréhensibles. C’est pareil avec Amber, backbone, spine… A chaque erreur, on doit, non pas regarder SON code, mais le code source du framework, pour voir le problème.&lt;/blockquote&gt;
Là, c&#039;est plus un problème des frameworks que du langage. Depuis récemment, les frameworks créent des extensions aux devtools pour leur framework. En gros, si tu utilises Ember, tu te mets aussi l&#039;addon qui va bien et tu peux débugger les abstractions Ember directement. On en est au début, mais c&#039;est prometteur.

&lt;blockquote&gt;On ne peut pas en JS. En JS, il faut d’abord apprendre la syntaxe du langage, et ensuite apprendre 3 tonnes de bonnes pratiques et patterns. En prime, il n’y a aucune doc centralisée pour vous dire comment faire.&lt;/blockquote&gt;

&quot;centralisée&quot;, ça va être compliqué, mais ce repo est un début https://github.com/rwaldron/idiomatic.js/
Je recense aussi les trucs pourris du langage https://github.com/DavidBruant/ECMAScript-regrets (un par issue).
Niveau outillage automatisé, je conseille eslint https://github.com/eslint/eslint/
TypeScript aussi fait du super boulot à garder le code sain et apporte très souvent d&#039;excellents messages d&#039;erreur.

&lt;blockquote&gt;Et non, ce lien ne permettra jamais à un de mes élèves de comprendre le prototypage.&lt;/blockquote&gt;

Le lien tout seul non, mais assisté de cet outil, j&#039;ai expliqué la notion en formation, les gens ont compris (j&#039;ai créé l&#039;outil spécifiquement pour ça).
En complément : https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain

&lt;blockquote&gt;Ce paragraphe est à lui seul une argumentation en ma faveur. Des features qui arrivent “dans le future”, donc un langage sur lequel tout le monde est d’accord qu’elles manquent. Mais qu’on ne pourra utiliser que dans 2, 3 ans.&lt;/blockquote&gt;

Nan, avec TypeScript ou Traceur, on peut utiliser la plupart des syntaxes ajoutées dans ES6 dès aujourd&#039;hui. Et ça compile vers ES3 (donc compatible IE8). Je l&#039;ai fait dans un vrai projet pour un client il y a un peu moins d&#039;un an. Ca s&#039;est bien passé.

&lt;blockquote&gt;Quand aux polyfills, j’ai du mal à voir comment suggérer du monkey patching comme rusting pour un manquement essentiel du langage peut mériter une smiley.&lt;/blockquote&gt;
Quand Brendan Eich conçoit le langage et l&#039;implémente en 10 jours, il sait qu&#039;il n&#039;aura pas le temps de tout faire proprement, alors il ouvre au Monkey patching en se disant que les gens rajouteront leurs propres trucs.
Le fait que Array.prototype.map ne soit pas implémenté dans IE8 n&#039;est pas un manquement du langage. Il existe une spec, tous les autres navigateurs l&#039;implémentent (IE8 a quand même implémenté une version toute pourrave de Object.defineProperty, ils auraient pu rajouter des trucs plus utiles).
La possibilité de faire des polyfills est une chance, surtout dans le contexte des navigateurs qui ne veulent pas partir comme IE8.

&lt;blockquote&gt;D’autant que les polyfills posent un AUTRE enorme problème pour quelqu’un qui n’est pas expert (comprendre, qui ne passe pas 1h par jour à se tenir au courant) :

- quel polyfill utiliser ?&lt;/blockquote&gt;
es5-shim https://github.com/es-shims/es5-shim (ou es5-sham si tu comprends et acceptes les limitations)
Sinon, plus généralement, la veille a été faite : https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills

&lt;blockquote&gt;- dois-je le faire à la main ?&lt;/blockquote&gt;
Non.

&lt;blockquote&gt;
- dois-je plutôt utiliser une lib ?
- si oui, lodash, underscore, jquery ?
&lt;/blockquote&gt;
Les libs ne rajoutent pas leur polyfills mais ont inventé leur équivalents (principalement parce qu&#039;ils ont commencé à une époque où on n&#039;avait pas vraiment compris la notion de polyfill).


&lt;blockquote&gt;Pour des features de base, on est déjà obligé de prendre ce genre de décisions. Ce n’est pas une bonne chose du tout.&lt;/blockquote&gt;
Histoire, legacy, regrets, colline ;-)


&lt;blockquote&gt;Oui encore un truc super chiant. Tous les moteurs ont leur numéro de version qui n’est pas calqué sur la spec ECMASCRIPT et c’est du travail de trouver les correspondances.&lt;/blockquote&gt;
Aucune importance. Versions ECMAScript comptent, le reste, c&#039;est à jeter.


&lt;blockquote&gt;Car Javascript est aussi un langage mal standardisé.&lt;/blockquote&gt;
Alors, c&#039;est compliqué de répondre à ça. En court, c&#039;est : non, oui, non.
ECMAScript est très très bien standardisé, genre choquant. Les différences d&#039;implémentations ECMAScript sont restées très subtiles, même sur les vieux IE et connues seulement des gros nerds (des trucs liés aux tableaux non-denses ou l&#039;ordre d&#039;énumération de for-in dans des conditions un peu ésotériques).
Le DOM est une autre histoire avec Microsoft qui s&#039;est senti pousser des ailes et proposer des choses encore pire que ce que le W3C avait pondu (sauf quelques bons trucs genre .innerHTML ou les iframes).
Tous les standards ont connu une période de gel pendant/suite à la guerre entre les navigateurs grossièrement entre 1999 et 2009, mais le support des standards qui existaient a convergé quand même sur les parties communes.
Historiquement, il a manqué un gros morceau concernant comment les APIs W3C étaient exposées en terme d&#039;ECMAScript (lié au fantasme ancien que les APIs seraient universelles et exposées dans plusieurs langages, genre Java, lol). Ce trou est en train d&#039;être comblé avec une spec qui s&#039;appelle WebIDL.
L&#039;effort actuel est standard est assez beau, je conseille de s&#039;y intéresser, je me demande si d&#039;autres langages ou écosystèmes sont aussi productifs dans leur capacité à se mettre d&#039;accord sur des features bien conçues.


&lt;blockquote&gt;Nope, pas sur IE8 sans polyfill&lt;/blockquote&gt;
Bah utilises un polyfill :-) T&#039;es quand même pas à 20 lignes de JS près...

&lt;blockquote&gt;Bref, j’espère que coffeescript ne gagnera pas.&lt;/blockquote&gt;
Personne ne gagnera. Les gens qui font du coffee vont continuer. Les gens qui font du TypeScript vont continuer, etc.

&lt;blockquote&gt; Je préfererais 100 fois qu’ils réparent les erreurs du JS et qu’on puisse l’utiliser proprement. Ce qu’ils sont heureusement en train de faire. Mais c’est lent.&lt;/blockquote&gt;

Ils ne peuvent pas réparer les erreurs, par contre, ils peuvent les cacher et encourager des meilleurs patterns. C&#039;est aussi ce que fait ES6 (de manière encore plus lente, mais c&#039;est pour notre bien).

&lt;blockquote&gt;Et si le Javascript pouvait aussi se taper des API synchrones, ce serait cool aussi. Parceque l’asynchrone, c’est hyper dur de former des gens dessus, et tout n’a pas besoin d’être async. En fait, à part pour la prog événementielle, on en a rarement besoin, donc comme paradigme par défaut, c’est chiant.&lt;/blockquote&gt;
Tu fais référence à Node? Parce que toutes les APIs async ont un équivalent avec le suffixe -Sync, genre &lt;a href=&quot;http://nodejs.org/api/fs.html#fs_fs_readfilesync_filename_options&quot; rel=&quot;nofollow&quot;&gt;fs.readFileSync&lt;/a&gt;.
Sinon, c&#039;est un très bon défaut tant que l&#039;oeil humain est sensible à des temps de l&#039;ordre de 100ms, que l&#039;on tape sur des serveurs sur un autre continent et que la vitesse de la lumière reste une barrière infranchissable ;-)
Le sauveur de l&#039;asychrone sans prise de tête, c&#039;est les promesses, mais le concept ne décolle que depuis ~2 ans et donc, Node.js avait déjà fait le choix des callbacks. Je ne fais rien d&#039;asynchrone sans promesses. Heureusement, ça arrive bientôt par défaut dans les navigateurs (et polyfills en attendant, évidemment)



J&#039;adore le petit Clippy ;-)]]></description>
		<content:encoded><![CDATA[<blockquote><p>On pourrait résumer cette réponse (à part quelques points encore une fois) à “C’est pourri mais c’est normal et il faut faire avec”.</p></blockquote>
<p>Oui. Il n&#8217;y a aucun débat sur le fait que JS est nul au niveau langage et même certaines API legacy genre le DOM (il y a un peu plus de débat sur d&#8217;autres aspects notamment doc, écosystèmes, communautés, etc.)</p>
<blockquote><p>Ca m’empeche pas quand je vois une situation de merde d’essayer d’y remedier.</p></blockquote>
<p>Je ne t&#8217;ai pas beaucoup vu sur <a href="https://mail.mozilla.org/pipermail/es-discuss/" rel="nofollow">es-discuss</a> et les autres mailing-lists de standards ;-)</p>
<blockquote><p>Mouahahahah. J’adore quand un spécialiste explique combien son outil est une grosse merde MAIS sic “il faut vivre avec” WTF! Le divorce c’est pas pour les chiens!</p></blockquote>
<p>C&#8217;est un peu par erreur que je suis devenu spécialiste. <a href="http://letrainde13h37.fr/47/dix-ans-pratique-javascript-paris/" rel="nofollow">Un peu comme Noëlie</a>, mais pas tout pareil.<br />
Il n&#8217;y a pas de divorce. Le web est bâti sur le principe de backward-compatibilité (pour des raisons économiques) et les navigateurs ont des <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=957431#c20" rel="nofollow">dilemmes moraux</a> dès qu&#8217;ils vont peut-être casser un site web (le lien que je donne, c&#8217;est vraiment juste un récent. Un parmi les 200 qu&#8217;ils ont par jour), donc on ne peut pas améliorer le langage en enlevant les merdes. Donc, il faut apprendre à éviter les pièges.</p>
<blockquote><p>La réponse est bonne, mais le mec en met des tartines pour justifier chaque point et comment faire avec/ne pas se faire mordre, ce qui confirme bien que c’est un mauvais langage :).</p></blockquote>
<p>Le mec te confirme :-) Mais on vit beaucoup mieux dès qu&#8217;on a accepté le truc. C&#8217;était un peu l&#8217;objet de mon propos. Si on espère que JS soit bien, on ne se créé que des frustrations. Pour vivre heureux, il faut accepter passer la colline de frustration qui consiste à dire que le JS c&#8217;est de la merde. En haut de cette colline, on peut alors réfléchir à comment on fait quand même des trucs, comment on se facilite la vie.</p>
<blockquote><p>C’est même pas tant le fait que ça soit asynchrone qui prime mais le fait que ça soit non-bloquant</p></blockquote>
<p>Oui. Je me fatigue, je fais toujours la confusion.</p>
<blockquote><p>Et si le JS avait gardé ses perfs d’origines, personne n’aurait levé les yeux sur node, asynchrone ou pas.</p></blockquote>
<p>Discutable, mais bon, on ne saura jamais.</p>
<blockquote><p>Qui fait du Javascript avec Rhino ?</p></blockquote>
<p>Je soupçonne que Google App Script et ses .gs, ça soit du Rhino en-dessous (avec des APIs à eux en plus&#8230; avec I/O bloquante -_-#). Mais oui, JS sans Node.js n&#8217;a pas grand sens.</p>
<blockquote><p>L’article est là pour pointer à quel point le JS est un langage pourri. La raison pour laquelle il l’est (une dette technique colossale), ne change pas ce point. Et le prix à payer est très lourd. C’est toujours chiant de devoir se coltiner un boulet alors qu’il y a de meilleurs outils à côté.</p></blockquote>
<p>Rejoins-moi de l&#8217;autre côté de la colline :-) Rester frustré ne sert à personne ;-)</p>
<blockquote><p>Le problème de new n’est pas pour les experts, c’est pour les non experts. En effet, Javascript ne lève aucune erreur si on oubli new</p></blockquote>
<p>Il n&#8217;y a pas de notion de constructeur dans le langage. Juste des fonctions et selon l&#8217;envie du moment, on décrète que c&#8217;est un constructeur ou pas et donc on décide de l’appeler avec new ou pas. Mais c&#8217;est plus une convention entre développeurs. C&#8217;est pour ça qu&#8217;il ne lève pas d&#8217;erreur.</p>
<blockquote><p>Debugger en JS, et c’est encore plus vrai quand on est pas expert, est une vrai torture comparé à la concurrence.</p></blockquote>
<p>Oui. Mais ça s&#8217;améliore dans les navigateurs. Node.js reste lamentable et c&#8217;est assez triste. Mais tout le monde est au courant, donc des gens bossent sur la question.</p>
<blockquote><p>C’est de pire en pire avec les nouveaux frameworks. Par exemple, j’utiliser Angularjs. Comme pour faire quelque chose de propre avec JS, ça demande pas mal d’abstraction et de magie, les messages d’erreurs sont incompréhensibles. C’est pareil avec Amber, backbone, spine… A chaque erreur, on doit, non pas regarder SON code, mais le code source du framework, pour voir le problème.</p></blockquote>
<p>Là, c&#8217;est plus un problème des frameworks que du langage. Depuis récemment, les frameworks créent des extensions aux devtools pour leur framework. En gros, si tu utilises Ember, tu te mets aussi l&#8217;addon qui va bien et tu peux débugger les abstractions Ember directement. On en est au début, mais c&#8217;est prometteur.</p>
<blockquote><p>On ne peut pas en JS. En JS, il faut d’abord apprendre la syntaxe du langage, et ensuite apprendre 3 tonnes de bonnes pratiques et patterns. En prime, il n’y a aucune doc centralisée pour vous dire comment faire.</p></blockquote>
<p>&#8220;centralisée&#8221;, ça va être compliqué, mais ce repo est un début <a href="https://github.com/rwaldron/idiomatic.js/" rel="nofollow">https://github.com/rwaldron/idiomatic.js/</a><br />
Je recense aussi les trucs pourris du langage <a href="https://github.com/DavidBruant/ECMAScript-regrets" rel="nofollow">https://github.com/DavidBruant/ECMAScript-regrets</a> (un par issue).<br />
Niveau outillage automatisé, je conseille eslint <a href="https://github.com/eslint/eslint/" rel="nofollow">https://github.com/eslint/eslint/</a><br />
TypeScript aussi fait du super boulot à garder le code sain et apporte très souvent d&#8217;excellents messages d&#8217;erreur.</p>
<blockquote><p>Et non, ce lien ne permettra jamais à un de mes élèves de comprendre le prototypage.</p></blockquote>
<p>Le lien tout seul non, mais assisté de cet outil, j&#8217;ai expliqué la notion en formation, les gens ont compris (j&#8217;ai créé l&#8217;outil spécifiquement pour ça).<br />
En complément : <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain" rel="nofollow">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain</a></p>
<blockquote><p>Ce paragraphe est à lui seul une argumentation en ma faveur. Des features qui arrivent “dans le future”, donc un langage sur lequel tout le monde est d’accord qu’elles manquent. Mais qu’on ne pourra utiliser que dans 2, 3 ans.</p></blockquote>
<p>Nan, avec TypeScript ou Traceur, on peut utiliser la plupart des syntaxes ajoutées dans ES6 dès aujourd&#8217;hui. Et ça compile vers ES3 (donc compatible IE8). Je l&#8217;ai fait dans un vrai projet pour un client il y a un peu moins d&#8217;un an. Ca s&#8217;est bien passé.</p>
<blockquote><p>Quand aux polyfills, j’ai du mal à voir comment suggérer du monkey patching comme rusting pour un manquement essentiel du langage peut mériter une smiley.</p></blockquote>
<p>Quand Brendan Eich conçoit le langage et l&#8217;implémente en 10 jours, il sait qu&#8217;il n&#8217;aura pas le temps de tout faire proprement, alors il ouvre au Monkey patching en se disant que les gens rajouteront leurs propres trucs.<br />
Le fait que Array.prototype.map ne soit pas implémenté dans IE8 n&#8217;est pas un manquement du langage. Il existe une spec, tous les autres navigateurs l&#8217;implémentent (IE8 a quand même implémenté une version toute pourrave de Object.defineProperty, ils auraient pu rajouter des trucs plus utiles).<br />
La possibilité de faire des polyfills est une chance, surtout dans le contexte des navigateurs qui ne veulent pas partir comme IE8.</p>
<blockquote><p>D’autant que les polyfills posent un AUTRE enorme problème pour quelqu’un qui n’est pas expert (comprendre, qui ne passe pas 1h par jour à se tenir au courant) :</p>
<p>&#8211; quel polyfill utiliser ?</p></blockquote>
<p>es5-shim <a href="https://github.com/es-shims/es5-shim" rel="nofollow">https://github.com/es-shims/es5-shim</a> (ou es5-sham si tu comprends et acceptes les limitations)<br />
Sinon, plus généralement, la veille a été faite : <a href="https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills" rel="nofollow">https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills</a></p>
<blockquote><p>- dois-je le faire à la main ?</p></blockquote>
<p>Non.</p>
<blockquote><p>
&#8211; dois-je plutôt utiliser une lib ?<br />
&#8211; si oui, lodash, underscore, jquery ?
</p></blockquote>
<p>Les libs ne rajoutent pas leur polyfills mais ont inventé leur équivalents (principalement parce qu&#8217;ils ont commencé à une époque où on n&#8217;avait pas vraiment compris la notion de polyfill).</p>
<blockquote><p>Pour des features de base, on est déjà obligé de prendre ce genre de décisions. Ce n’est pas une bonne chose du tout.</p></blockquote>
<p>Histoire, legacy, regrets, colline ;-)</p>
<blockquote><p>Oui encore un truc super chiant. Tous les moteurs ont leur numéro de version qui n’est pas calqué sur la spec ECMASCRIPT et c’est du travail de trouver les correspondances.</p></blockquote>
<p>Aucune importance. Versions ECMAScript comptent, le reste, c&#8217;est à jeter.</p>
<blockquote><p>Car Javascript est aussi un langage mal standardisé.</p></blockquote>
<p>Alors, c&#8217;est compliqué de répondre à ça. En court, c&#8217;est : non, oui, non.<br />
ECMAScript est très très bien standardisé, genre choquant. Les différences d&#8217;implémentations ECMAScript sont restées très subtiles, même sur les vieux IE et connues seulement des gros nerds (des trucs liés aux tableaux non-denses ou l&#8217;ordre d&#8217;énumération de for-in dans des conditions un peu ésotériques).<br />
Le DOM est une autre histoire avec Microsoft qui s&#8217;est senti pousser des ailes et proposer des choses encore pire que ce que le W3C avait pondu (sauf quelques bons trucs genre .innerHTML ou les iframes).<br />
Tous les standards ont connu une période de gel pendant/suite à la guerre entre les navigateurs grossièrement entre 1999 et 2009, mais le support des standards qui existaient a convergé quand même sur les parties communes.<br />
Historiquement, il a manqué un gros morceau concernant comment les APIs W3C étaient exposées en terme d&#8217;ECMAScript (lié au fantasme ancien que les APIs seraient universelles et exposées dans plusieurs langages, genre Java, lol). Ce trou est en train d&#8217;être comblé avec une spec qui s&#8217;appelle WebIDL.<br />
L&#8217;effort actuel est standard est assez beau, je conseille de s&#8217;y intéresser, je me demande si d&#8217;autres langages ou écosystèmes sont aussi productifs dans leur capacité à se mettre d&#8217;accord sur des features bien conçues.</p>
<blockquote><p>Nope, pas sur IE8 sans polyfill</p></blockquote>
<p>Bah utilises un polyfill :-) T&#8217;es quand même pas à 20 lignes de JS près&#8230;</p>
<blockquote><p>Bref, j’espère que coffeescript ne gagnera pas.</p></blockquote>
<p>Personne ne gagnera. Les gens qui font du coffee vont continuer. Les gens qui font du TypeScript vont continuer, etc.</p>
<blockquote><p> Je préfererais 100 fois qu’ils réparent les erreurs du JS et qu’on puisse l’utiliser proprement. Ce qu’ils sont heureusement en train de faire. Mais c’est lent.</p></blockquote>
<p>Ils ne peuvent pas réparer les erreurs, par contre, ils peuvent les cacher et encourager des meilleurs patterns. C&#8217;est aussi ce que fait ES6 (de manière encore plus lente, mais c&#8217;est pour notre bien).</p>
<blockquote><p>Et si le Javascript pouvait aussi se taper des API synchrones, ce serait cool aussi. Parceque l’asynchrone, c’est hyper dur de former des gens dessus, et tout n’a pas besoin d’être async. En fait, à part pour la prog événementielle, on en a rarement besoin, donc comme paradigme par défaut, c’est chiant.</p></blockquote>
<p>Tu fais référence à Node? Parce que toutes les APIs async ont un équivalent avec le suffixe -Sync, genre <a href="http://nodejs.org/api/fs.html#fs_fs_readfilesync_filename_options" rel="nofollow">fs.readFileSync</a>.<br />
Sinon, c&#8217;est un très bon défaut tant que l&#8217;oeil humain est sensible à des temps de l&#8217;ordre de 100ms, que l&#8217;on tape sur des serveurs sur un autre continent et que la vitesse de la lumière reste une barrière infranchissable ;-)<br />
Le sauveur de l&#8217;asychrone sans prise de tête, c&#8217;est les promesses, mais le concept ne décolle que depuis ~2 ans et donc, Node.js avait déjà fait le choix des callbacks. Je ne fais rien d&#8217;asynchrone sans promesses. Heureusement, ça arrive bientôt par défaut dans les navigateurs (et polyfills en attendant, évidemment)</p>
<p>J&#8217;adore le petit Clippy ;-)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Tom</title>
		<link>http://sametmax.com/droit-de-reponse-au-troll-js/#comment-21562</link>
		<dc:creator><![CDATA[Tom]]></dc:creator>
		<pubDate>Wed, 19 Mar 2014 20:07:03 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=9812#comment-21562</guid>
		<description><![CDATA[Bon je suis encore loin de vos considérations de programmation avancées, mais je veux juste dire que c&#039;est grâce (ou à cause selon le point de vue) de votre article troll que je me suis mis sérieusement au js... Oui je sais c&#039;est pas vraiment logique...]]></description>
		<content:encoded><![CDATA[<p>Bon je suis encore loin de vos considérations de programmation avancées, mais je veux juste dire que c&#8217;est grâce (ou à cause selon le point de vue) de votre article troll que je me suis mis sérieusement au js&#8230; Oui je sais c&#8217;est pas vraiment logique&#8230;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sam</title>
		<link>http://sametmax.com/droit-de-reponse-au-troll-js/#comment-21555</link>
		<dc:creator><![CDATA[Sam]]></dc:creator>
		<pubDate>Wed, 19 Mar 2014 18:13:17 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=9812#comment-21555</guid>
		<description><![CDATA[Un autre avantage de la publication : je peux répondre ^^

&lt;blockquote&gt;Nan, c’est parce que Ryan Dahl a compris l’importance de la programmation asynchrone et que les gens qui font du JS sont déjà dans le moule de l’asynchrone et que c’était donc une communauté facile à convaincre.
C’est juste une bonne coïncidence qu’au moins une VM très performante est dispo.

Node.js massacre beaucoup d’autres langages en performance grâce à l’asynchrone, pas grand chose d’autre, sûrement pas la “vitesse du langage”.
&lt;/blockquote&gt;


L&#039;asynchrone existe avec des tas d&#039;autres langages. &lt;a href=&quot;https://fr.wikipedia.org/wiki/Twisted&quot; rel=&quot;nofollow&quot;&gt;Twisted&lt;/a&gt; existait avant nodejs, Erlang aussi. Et si le JS avait gardé ses perfs d&#039;origines, personne n&#039;aurait levé les yeux sur node, asynchrone ou pas.

En effet, ça ne sert à rien d&#039;avoir un super framework asynchrone si il passe 30% du temps sur le rendu des templates. Les gens prennent la VM de chrome comme quelque chose de normal maintenant, mais il faut se souvenir à quel point Javascript était incroyablement LENT. Vraiment. Très. Lent.


&lt;blockquote&gt;On compare des choux et des carottes. Un langage (syntaxe, sémantique) ne sert à rien. Il faut toujours des trucs en plus. Dans un contexte web, à quoi sert Ruby sans Rails ?&lt;/blockquote&gt;

NodeJs, ce n&#039;est pas juste une VM, c&#039;est une framework. Ruby permet de faire des choses avec sa stdlib. Python permet de faire énormément de chose avec. Sans framework. Autre chose : Python est aussi utile avec ses autres implémentation (Jython pour la JVM, Pypy pour du JIT, IronPython pour tourner sur .net, etc). Qui fait du Javascript avec Rhino ? La prog JS serveur est complètement dépendante de Node, en plus d&#039;être dépendante d&#039;une runtime javascript.


&lt;blockquote&gt;Le web est un pari ambitieux qui a des coûts. Mais il faut aussi comprendre les enjeux du web. Aucun téléphone ne sort sans navigateur web aujourd’hui. Ca n’est même pas une discussion. Ca a des coûts qui vont avec. On peut rêver d’un autre monde, mais essayons d’avancer dans celui qu’on a entre temps ;-)

...

Bienvenue dans l’humanité ;-)
&lt;/blockquote&gt;

On est d&#039;accord sur ce point, j&#039;avais juste besoin de passer mes nerfs sur quelque chose. Ca va mieux maintenant.

&lt;blockquote&gt;Du fat d’être langage du web et de la contrainte de backward-compat du web, JS ne peut pas se débarrasser de ses bad parts. J’ai donné un talk sur le sujet. Être efficace en JS nécessite de comprendre un peu son histoire et les pièges à éviter. C’est le coût d’être le langage du web. Mais c’est bien le web, non ? Ca vaut le coup, non ?&lt;/blockquote&gt;

Ce n&#039;est pas l&#039;objet de l&#039;article. L&#039;article est là pour pointer à quel point le JS est un langage pourri. La raison pour laquelle il l&#039;est (une dette technique colossale), ne change pas ce point. Et le prix à payer est très lourd. C&#039;est toujours chiant de devoir se coltiner un boulet alors qu&#039;il y a de meilleurs outils à côté.


&lt;blockquote&gt;wtf? N’importe quoi ! La spec ECMAScript 5 est la référence pour les différences entre strict et “sloppy” mode. Pour des ressources un peu plus digestes :
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode/Transitioning_to_strict_mode

...

Mais c’est quoi ce business de la désinformation !!
a = 1 est une expression qui permet de faire a = b = 1, donc sa valeur est la valeur de la sous-expression de droite. var a = 1 n’est pas une expression (if(var a = 1){} est une SyntaxError), donc le REPL se contente de retourner undefined, mais ça n’a aucune importance en pratique.&lt;/blockquote&gt;

J&#039;ai dis de la merde. Mea culpa.

&lt;blockquote&gt;Douglas Crockford est une seule personne. On a le droit aussi de ne pas être d’accord. Utiliser with, c’est souvent se tirer une balle dans le pied, d’où le bannissement dans le strict mode. Mais new, c’est plus une question de style. Je suis assez expert JS, j’utilise new et je le vis bien.&lt;/blockquote&gt;

Le problème de new n&#039;est pas pour les experts, c&#039;est pour les non experts. En effet, Javascript ne lève aucune erreur si on oubli new :

&lt;pre lang=&quot;javascript&quot;&gt;&gt; function test(){}
undefined
&gt; test()
undefined
&gt; new test()
{}&lt;/pre&gt;

Ca pose le même problème que :

&lt;blockquote&gt;    J’ouvre Firefox, je tape [] + {}

J’écris ça quotidiennement aussi, ça m’aide beaucoup pour écrire des interfaces facilement utilisables par les utilisateurs. [] + {} créé aussi des méta-promesses qui permettent de faire de l’asynchrone un peu plus rapide que la vitesse de la lumière.&lt;/blockquote&gt;

Le problème n&#039;est pas la difficulté intrinsèque posés par ce genre de détail, c&#039;est que quand (et pas SI) il y aura un bug, ça va rendre le truc hyper chiant à debugger. Debugger en JS, et c&#039;est encore plus vrai quand on est pas expert, est une vrai torture comparé à la concurrence.

Un langage, ce n&#039;est pas juste des fonctionalités métiers, c&#039;est aussi :

- la lisibilité
- la facilité de debug
- la communauté
- la doc

Le Js à la communauté, mais pêche beaucoup sur les 3 autres points. Il ne faut pas se faire l&#039;avocat du diable. Que ce soit une techno qui fasse le boulot, tout le monde est d&#039;accord. Mais on passe notre temps de dev à la tordre dans tous les sens pour ce faire. 

C&#039;est de pire en pire avec les nouveaux frameworks. Par exemple, j&#039;utiliser Angularjs. Comme pour faire quelque chose de propre avec JS, ça demande pas mal d&#039;abstraction et de magie, les messages d&#039;erreurs sont incompréhensibles. C&#039;est pareil avec Amber, backbone, spine... A chaque erreur, on doit, non pas regarder SON code, mais le code source du framework, pour voir le problème.

Je ne dis pas que ça ne m&#039;arrive jamais de devoir jeter un coup d&#039;oeil dans les entrailles de Django pour comprendre l&#039;origine d&#039;un problème, mais c&#039;est rare. La stack trace est clair, les messages d&#039;erreurs sont généralement assez directes, et surtout, le langage n&#039;a pas de trucs bizarre comme les problèmes vus plus hauts qui transforment parfois la chasse aux bugs en une décente dans l&#039;imaginarium du doctor parnassus.


&lt;blockquote&gt;En français aussi, il y a des figures de style. En l’état, on peut écrire du JS propre. Je veux bien admettre que ça exige beaucoup plus de disciplines que d’autres langages, mais ça s’arrête là. Encore une fois, JS est obligé de porter le poids de son histoire parce que c’est le langage du web.

http://davidbruant.github.io/ObjectViz/
&lt;/blockquote&gt;

Là c&#039;est de la mauvaise foi. Outre que le français est une langage qui évolue organiquement depuis près des siècles et JS un langage artificiel technique qui est à peine majeur, on peut écrire du français propre et lisible sans figure de style.

On ne peut pas en JS. En JS, il faut d&#039;abord apprendre la syntaxe du langage, et ensuite apprendre 3 tonnes de bonnes pratiques et patterns. En prime, il n&#039;y a aucune doc centralisée pour vous dire comment faire.

Et non, ce lien ne permettra jamais à un de mes élèves de comprendre le prototypage. C&#039;est aussi difficile à expliquer que les metaclasses en Python. Sauf que les metaclasses, c&#039;est pas une notion essentielle.

&lt;blockquote&gt;
    chaines multilignes

Ca arrive dans ES6 https://gist.github.com/lukehoban/9303054#template-strings

    list compréhension à la Python

ES6 : https://gist.github.com/lukehoban/9303054#comprehensions
Implémenté dans Firefox et dans la Nightly depuis la semaine dernière.&lt;/blockquote&gt;

    Et encore, je suis cool, je mets un code JS qui utilise l.length directement dans la boucle et pas de variable pour l[i].

Nan, mais c’est bon, on est en 2014, plus besoin de ces conneries :-) Y’en a jamais eu besoin, c’était juste de la micro-optimisations de gens qui pensaient que ça avait un impact significatif après qu’ils aient fait un micro-benchmark sur le sujet.

    Array.map arrive avec JS 1.6 et les arrays comprehensions avec la 1.7…

Cute :-)
Array.prototype.map, on peut le polyfiller
&lt;/blockquote&gt;

Ce paragraphe est à lui seul une argumentation en ma faveur. Des features qui arrivent &quot;dans le future&quot;, donc un langage sur lequel tout le monde est d&#039;accord qu&#039;elles manquent. Mais qu&#039;on ne pourra utiliser que dans 2, 3 ans. Quand les autres langages 

Quand aux polyfills, j&#039;ai du mal à voir comment suggérer du monkey patching comme rusting pour un manquement essentiel du langage peut mériter une smiley. D&#039;autant que les polyfills posent un AUTRE enorme problème pour quelqu&#039;un qui n&#039;est pas expert (comprendre, qui ne passe pas 1h par jour à se tenir au courant) :

- quel polyfill utiliser ?
- dois-je le faire à la main ?
- dois-je plutôt utiliser une lib ?
- si oui, lodash, underscore, jquery ?

Pour des features de base, on est déjà obligé de prendre ce genre de décisions. Ce n&#039;est pas une bonne chose du tout.

&lt;blockquote&gt;JavaScript 1.6, 1.7, ça n’existe pas. C’est des gens chez Mozilla, ils étaient bourrés (Brendan Eich a continué à boire même après avoir créé et shippé JS en 10 jours), ils ont donné des numéros de version, après le mot “JavaScript”, mais c’était pour rire (c’était lié au numéro de version de SpiderMonkey, moteur JS de Firefox). Seuls les numéros de spec d’ECMAScript ont un sens un peu sérieux.&lt;/blockquote&gt;

Oui encore un truc super chiant. Tous les moteurs ont leur numéro de version qui n&#039;est pas calqué sur la spec ECMASCRIPT et c&#039;est du travail de trouver les correspondances. Car Javascript est aussi un langage mal standardisé. Comme je le disais ailleurs, les différents implémentation de Python ont beaucoup moins ce problème. La standardisation a été bien mieux foutue. Après, le Javascript se tape le boulet IE et donc la vision très conceptuelle de collaboration de Microsoft donc ceci explique cela. Et c&#039;est plus dur de faire collaborer des grosses boîtes que des structures open source.


&lt;blockquote&gt;.map tu peux l’utiliser depuis des années. Les array compréhension, ça marche sur Traceur&lt;/blockquote&gt;

Nope, pas sur IE8 sans polyfill, qui fait 30% de notre trafique.


Tiens https://gist.github.com/lukehoban/9303054#default–rest–spread
J’ai utilisé ça en TypeScript (mais ceux qui préfèrent Traceur peuvent aussi choisir ça) sur un vrai projet qui tourne sur de vrais mobiles il y a presque un an.


C&#039;est aussi une tendance actuelle

    Ah mais il faut utiliser coffeescript !
    Oui donc pas Javascript. Point made.

Jeremy Ashkenas, inventeur de CoffeeScript le décrit en disant “it’s just JavaScript”. Je dis ça…

Oui et microsft a dis &quot;it&#039;s not a bug, it&#039;s a feature&quot;. Une phrase marketing n&#039;est pas un fait. Le coffescript ne tourne pas nativement sur les navigateurs ou sous node.

Et le pire, c&#039;est que j&#039;ai horreur de la syntaxe de coffeescript. C&#039;est une amélioration pour plein de chose, mais un grand pas en arrière pour d&#039;autres choses. Par exemple, la déclaration des fonctions a été tellement dépouillées de délimiteurs que le cerveau est obligé d&#039;analyser le contexte de l&#039;instruction pour comprendre ce qui se passe. Cela augmente fortement la charge cognitive lors de la lecture d&#039;un code coffeescript, et on lit un code bien plus souvent qu&#039;on l&#039;écrit. Bref, j&#039;espère que coffeescript ne gagnera pas. Je préfererais 100 fois qu&#039;ils réparent les erreurs du JS et qu&#039;on puisse l&#039;utiliser proprement. Ce qu&#039;ils sont heureusement en train de faire. Mais c&#039;est lent.

Et si le Javascript pouvait aussi se taper des API synchrones, ce serait cool aussi. Parceque l&#039;asynchrone, c&#039;est hyper dur de former des gens dessus, et tout n&#039;a pas besoin d&#039;être async. En fait, à part pour la prog événementielle, on en a rarement besoin, donc comme paradigme par défaut, c&#039;est chiant.

&lt;blockquote&gt;Aucune importance. C’est ce qu’on a, il faut vivre avec, bon gré mal gré.

Gros bisous,

David&lt;/blockquote&gt;

Ouai. Snif. Calin.]]></description>
		<content:encoded><![CDATA[<p>Un autre avantage de la publication : je peux répondre ^^</p>
<blockquote><p>Nan, c’est parce que Ryan Dahl a compris l’importance de la programmation asynchrone et que les gens qui font du JS sont déjà dans le moule de l’asynchrone et que c’était donc une communauté facile à convaincre.<br />
C’est juste une bonne coïncidence qu’au moins une VM très performante est dispo.</p>
<p>Node.js massacre beaucoup d’autres langages en performance grâce à l’asynchrone, pas grand chose d’autre, sûrement pas la “vitesse du langage”.
</p></blockquote>
<p>L&#8217;asynchrone existe avec des tas d&#8217;autres langages. <a href="https://fr.wikipedia.org/wiki/Twisted" rel="nofollow">Twisted</a> existait avant nodejs, Erlang aussi. Et si le JS avait gardé ses perfs d&#8217;origines, personne n&#8217;aurait levé les yeux sur node, asynchrone ou pas.</p>
<p>En effet, ça ne sert à rien d&#8217;avoir un super framework asynchrone si il passe 30% du temps sur le rendu des templates. Les gens prennent la VM de chrome comme quelque chose de normal maintenant, mais il faut se souvenir à quel point Javascript était incroyablement LENT. Vraiment. Très. Lent.</p>
<blockquote><p>On compare des choux et des carottes. Un langage (syntaxe, sémantique) ne sert à rien. Il faut toujours des trucs en plus. Dans un contexte web, à quoi sert Ruby sans Rails ?</p></blockquote>
<p>NodeJs, ce n&#8217;est pas juste une VM, c&#8217;est une framework. Ruby permet de faire des choses avec sa stdlib. Python permet de faire énormément de chose avec. Sans framework. Autre chose : Python est aussi utile avec ses autres implémentation (Jython pour la JVM, Pypy pour du JIT, IronPython pour tourner sur .net, etc). Qui fait du Javascript avec Rhino ? La prog JS serveur est complètement dépendante de Node, en plus d&#8217;être dépendante d&#8217;une runtime javascript.</p>
<blockquote><p>Le web est un pari ambitieux qui a des coûts. Mais il faut aussi comprendre les enjeux du web. Aucun téléphone ne sort sans navigateur web aujourd’hui. Ca n’est même pas une discussion. Ca a des coûts qui vont avec. On peut rêver d’un autre monde, mais essayons d’avancer dans celui qu’on a entre temps ;-)</p>
<p>&#8230;</p>
<p>Bienvenue dans l’humanité ;-)
</p></blockquote>
<p>On est d&#8217;accord sur ce point, j&#8217;avais juste besoin de passer mes nerfs sur quelque chose. Ca va mieux maintenant.</p>
<blockquote><p>Du fat d’être langage du web et de la contrainte de backward-compat du web, JS ne peut pas se débarrasser de ses bad parts. J’ai donné un talk sur le sujet. Être efficace en JS nécessite de comprendre un peu son histoire et les pièges à éviter. C’est le coût d’être le langage du web. Mais c’est bien le web, non ? Ca vaut le coup, non ?</p></blockquote>
<p>Ce n&#8217;est pas l&#8217;objet de l&#8217;article. L&#8217;article est là pour pointer à quel point le JS est un langage pourri. La raison pour laquelle il l&#8217;est (une dette technique colossale), ne change pas ce point. Et le prix à payer est très lourd. C&#8217;est toujours chiant de devoir se coltiner un boulet alors qu&#8217;il y a de meilleurs outils à côté.</p>
<blockquote><p>wtf? N’importe quoi ! La spec ECMAScript 5 est la référence pour les différences entre strict et “sloppy” mode. Pour des ressources un peu plus digestes :<br />
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode" rel="nofollow">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode</a><br />
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode/Transitioning_to_strict_mode" rel="nofollow">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode/Transitioning_to_strict_mode</a></p>
<p>&#8230;</p>
<p>Mais c’est quoi ce business de la désinformation !!<br />
a = 1 est une expression qui permet de faire a = b = 1, donc sa valeur est la valeur de la sous-expression de droite. var a = 1 n’est pas une expression (if(var a = 1){} est une SyntaxError), donc le REPL se contente de retourner undefined, mais ça n’a aucune importance en pratique.</p></blockquote>
<p>J&#8217;ai dis de la merde. Mea culpa.</p>
<blockquote><p>Douglas Crockford est une seule personne. On a le droit aussi de ne pas être d’accord. Utiliser with, c’est souvent se tirer une balle dans le pied, d’où le bannissement dans le strict mode. Mais new, c’est plus une question de style. Je suis assez expert JS, j’utilise new et je le vis bien.</p></blockquote>
<p>Le problème de new n&#8217;est pas pour les experts, c&#8217;est pour les non experts. En effet, Javascript ne lève aucune erreur si on oubli new :</p>

<div class="wp_syntax"><table><tr><td class="code"><pre class="javascript" style="font-family:monospace;"><span style="color: #339933;">&gt;</span> <span style="color: #000066; font-weight: bold;">function</span> test<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span><span style="color: #009900;">&#125;</span>
<span style="color: #003366; font-weight: bold;">undefined</span>
<span style="color: #339933;">&gt;</span> test<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span>
<span style="color: #003366; font-weight: bold;">undefined</span>
<span style="color: #339933;">&gt;</span> <span style="color: #000066; font-weight: bold;">new</span> test<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span>
<span style="color: #009900;">&#123;</span><span style="color: #009900;">&#125;</span></pre></td></tr></table></div>

<p>Ca pose le même problème que :</p>
<blockquote><p>    J’ouvre Firefox, je tape [] + {}</p>
<p>J’écris ça quotidiennement aussi, ça m’aide beaucoup pour écrire des interfaces facilement utilisables par les utilisateurs. [] + {} créé aussi des méta-promesses qui permettent de faire de l’asynchrone un peu plus rapide que la vitesse de la lumière.</p></blockquote>
<p>Le problème n&#8217;est pas la difficulté intrinsèque posés par ce genre de détail, c&#8217;est que quand (et pas SI) il y aura un bug, ça va rendre le truc hyper chiant à debugger. Debugger en JS, et c&#8217;est encore plus vrai quand on est pas expert, est une vrai torture comparé à la concurrence.</p>
<p>Un langage, ce n&#8217;est pas juste des fonctionalités métiers, c&#8217;est aussi :</p>
<p>&#8211; la lisibilité<br />
&#8211; la facilité de debug<br />
&#8211; la communauté<br />
&#8211; la doc</p>
<p>Le Js à la communauté, mais pêche beaucoup sur les 3 autres points. Il ne faut pas se faire l&#8217;avocat du diable. Que ce soit une techno qui fasse le boulot, tout le monde est d&#8217;accord. Mais on passe notre temps de dev à la tordre dans tous les sens pour ce faire. </p>
<p>C&#8217;est de pire en pire avec les nouveaux frameworks. Par exemple, j&#8217;utiliser Angularjs. Comme pour faire quelque chose de propre avec JS, ça demande pas mal d&#8217;abstraction et de magie, les messages d&#8217;erreurs sont incompréhensibles. C&#8217;est pareil avec Amber, backbone, spine&#8230; A chaque erreur, on doit, non pas regarder SON code, mais le code source du framework, pour voir le problème.</p>
<p>Je ne dis pas que ça ne m&#8217;arrive jamais de devoir jeter un coup d&#8217;oeil dans les entrailles de Django pour comprendre l&#8217;origine d&#8217;un problème, mais c&#8217;est rare. La stack trace est clair, les messages d&#8217;erreurs sont généralement assez directes, et surtout, le langage n&#8217;a pas de trucs bizarre comme les problèmes vus plus hauts qui transforment parfois la chasse aux bugs en une décente dans l&#8217;imaginarium du doctor parnassus.</p>
<blockquote><p>En français aussi, il y a des figures de style. En l’état, on peut écrire du JS propre. Je veux bien admettre que ça exige beaucoup plus de disciplines que d’autres langages, mais ça s’arrête là. Encore une fois, JS est obligé de porter le poids de son histoire parce que c’est le langage du web.</p>
<p><a href="http://davidbruant.github.io/ObjectViz/" rel="nofollow">http://davidbruant.github.io/ObjectViz/</a>
</p></blockquote>
<p>Là c&#8217;est de la mauvaise foi. Outre que le français est une langage qui évolue organiquement depuis près des siècles et JS un langage artificiel technique qui est à peine majeur, on peut écrire du français propre et lisible sans figure de style.</p>
<p>On ne peut pas en JS. En JS, il faut d&#8217;abord apprendre la syntaxe du langage, et ensuite apprendre 3 tonnes de bonnes pratiques et patterns. En prime, il n&#8217;y a aucune doc centralisée pour vous dire comment faire.</p>
<p>Et non, ce lien ne permettra jamais à un de mes élèves de comprendre le prototypage. C&#8217;est aussi difficile à expliquer que les metaclasses en Python. Sauf que les metaclasses, c&#8217;est pas une notion essentielle.</p>
<blockquote><p>
    chaines multilignes</p>
<p>Ca arrive dans ES6 <a href="https://gist.github.com/lukehoban/9303054#template-strings" rel="nofollow">https://gist.github.com/lukehoban/9303054#template-strings</a></p>
<p>    list compréhension à la Python</p>
<p>ES6 : <a href="https://gist.github.com/lukehoban/9303054#comprehensions" rel="nofollow">https://gist.github.com/lukehoban/9303054#comprehensions</a><br />
Implémenté dans Firefox et dans la Nightly depuis la semaine dernière.</p></blockquote>
<p>    Et encore, je suis cool, je mets un code JS qui utilise l.length directement dans la boucle et pas de variable pour l[i].</p>
<p>Nan, mais c’est bon, on est en 2014, plus besoin de ces conneries :-) Y’en a jamais eu besoin, c’était juste de la micro-optimisations de gens qui pensaient que ça avait un impact significatif après qu’ils aient fait un micro-benchmark sur le sujet.</p>
<p>    Array.map arrive avec JS 1.6 et les arrays comprehensions avec la 1.7…</p>
<p>Cute :-)<br />
Array.prototype.map, on peut le polyfiller</p>
<p>Ce paragraphe est à lui seul une argumentation en ma faveur. Des features qui arrivent &#8220;dans le future&#8221;, donc un langage sur lequel tout le monde est d&#8217;accord qu&#8217;elles manquent. Mais qu&#8217;on ne pourra utiliser que dans 2, 3 ans. Quand les autres langages </p>
<p>Quand aux polyfills, j&#8217;ai du mal à voir comment suggérer du monkey patching comme rusting pour un manquement essentiel du langage peut mériter une smiley. D&#8217;autant que les polyfills posent un AUTRE enorme problème pour quelqu&#8217;un qui n&#8217;est pas expert (comprendre, qui ne passe pas 1h par jour à se tenir au courant) :</p>
<p>&#8211; quel polyfill utiliser ?<br />
&#8211; dois-je le faire à la main ?<br />
&#8211; dois-je plutôt utiliser une lib ?<br />
&#8211; si oui, lodash, underscore, jquery ?</p>
<p>Pour des features de base, on est déjà obligé de prendre ce genre de décisions. Ce n&#8217;est pas une bonne chose du tout.</p>
<blockquote><p>JavaScript 1.6, 1.7, ça n’existe pas. C’est des gens chez Mozilla, ils étaient bourrés (Brendan Eich a continué à boire même après avoir créé et shippé JS en 10 jours), ils ont donné des numéros de version, après le mot “JavaScript”, mais c’était pour rire (c’était lié au numéro de version de SpiderMonkey, moteur JS de Firefox). Seuls les numéros de spec d’ECMAScript ont un sens un peu sérieux.</p></blockquote>
<p>Oui encore un truc super chiant. Tous les moteurs ont leur numéro de version qui n&#8217;est pas calqué sur la spec ECMASCRIPT et c&#8217;est du travail de trouver les correspondances. Car Javascript est aussi un langage mal standardisé. Comme je le disais ailleurs, les différents implémentation de Python ont beaucoup moins ce problème. La standardisation a été bien mieux foutue. Après, le Javascript se tape le boulet IE et donc la vision très conceptuelle de collaboration de Microsoft donc ceci explique cela. Et c&#8217;est plus dur de faire collaborer des grosses boîtes que des structures open source.</p>
<blockquote><p>.map tu peux l’utiliser depuis des années. Les array compréhension, ça marche sur Traceur</p></blockquote>
<p>Nope, pas sur IE8 sans polyfill, qui fait 30% de notre trafique.</p>
<p>Tiens <a href="https://gist.github.com/lukehoban/9303054#default–rest–spread" rel="nofollow">https://gist.github.com/lukehoban/9303054#default–rest–spread</a><br />
J’ai utilisé ça en TypeScript (mais ceux qui préfèrent Traceur peuvent aussi choisir ça) sur un vrai projet qui tourne sur de vrais mobiles il y a presque un an.</p>
<p>C&#8217;est aussi une tendance actuelle</p>
<p>    Ah mais il faut utiliser coffeescript !<br />
    Oui donc pas Javascript. Point made.</p>
<p>Jeremy Ashkenas, inventeur de CoffeeScript le décrit en disant “it’s just JavaScript”. Je dis ça…</p>
<p>Oui et microsft a dis &#8220;it&#8217;s not a bug, it&#8217;s a feature&#8221;. Une phrase marketing n&#8217;est pas un fait. Le coffescript ne tourne pas nativement sur les navigateurs ou sous node.</p>
<p>Et le pire, c&#8217;est que j&#8217;ai horreur de la syntaxe de coffeescript. C&#8217;est une amélioration pour plein de chose, mais un grand pas en arrière pour d&#8217;autres choses. Par exemple, la déclaration des fonctions a été tellement dépouillées de délimiteurs que le cerveau est obligé d&#8217;analyser le contexte de l&#8217;instruction pour comprendre ce qui se passe. Cela augmente fortement la charge cognitive lors de la lecture d&#8217;un code coffeescript, et on lit un code bien plus souvent qu&#8217;on l&#8217;écrit. Bref, j&#8217;espère que coffeescript ne gagnera pas. Je préfererais 100 fois qu&#8217;ils réparent les erreurs du JS et qu&#8217;on puisse l&#8217;utiliser proprement. Ce qu&#8217;ils sont heureusement en train de faire. Mais c&#8217;est lent.</p>
<p>Et si le Javascript pouvait aussi se taper des API synchrones, ce serait cool aussi. Parceque l&#8217;asynchrone, c&#8217;est hyper dur de former des gens dessus, et tout n&#8217;a pas besoin d&#8217;être async. En fait, à part pour la prog événementielle, on en a rarement besoin, donc comme paradigme par défaut, c&#8217;est chiant.</p>
<blockquote><p>Aucune importance. C’est ce qu’on a, il faut vivre avec, bon gré mal gré.</p>
<p>Gros bisous,</p>
<p>David</p></blockquote>
<p>Ouai. Snif. Calin.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sam</title>
		<link>http://sametmax.com/droit-de-reponse-au-troll-js/#comment-21554</link>
		<dc:creator><![CDATA[Sam]]></dc:creator>
		<pubDate>Wed, 19 Mar 2014 18:12:37 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=9812#comment-21554</guid>
		<description><![CDATA[@Oncle Tom: http://sametmax.com/la-difference-entre-la-programmation-asynchrone-parallele-et-concurrente/]]></description>
		<content:encoded><![CDATA[<p>@Oncle Tom: <a href="http://sametmax.com/la-difference-entre-la-programmation-asynchrone-parallele-et-concurrente/" rel="nofollow">http://sametmax.com/la-difference-entre-la-programmation-asynchrone-parallele-et-concurrente/</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Mathieu</title>
		<link>http://sametmax.com/droit-de-reponse-au-troll-js/#comment-21551</link>
		<dc:creator><![CDATA[Mathieu]]></dc:creator>
		<pubDate>Wed, 19 Mar 2014 15:31:18 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=9812#comment-21551</guid>
		<description><![CDATA[La réponse est bonne, mais le mec en met des tartines pour justifier chaque point et comment faire avec/ne pas se faire mordre, ce qui confirme bien que c&#039;est un mauvais langage :).]]></description>
		<content:encoded><![CDATA[<p>La réponse est bonne, mais le mec en met des tartines pour justifier chaque point et comment faire avec/ne pas se faire mordre, ce qui confirme bien que c&#8217;est un mauvais langage :).</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: kontre</title>
		<link>http://sametmax.com/droit-de-reponse-au-troll-js/#comment-21548</link>
		<dc:creator><![CDATA[kontre]]></dc:creator>
		<pubDate>Wed, 19 Mar 2014 14:41:16 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=9812#comment-21548</guid>
		<description><![CDATA[@Oncle Tom: C&#039;est quoi la différence entre asynchrone et non bloquant ?
Si c&#039;est asynchrone, c&#039;est pas bloquant. Si c&#039;est pas bloquant, ça ne peut pas être synchrone.]]></description>
		<content:encoded><![CDATA[<p>@Oncle Tom: C&#8217;est quoi la différence entre asynchrone et non bloquant ?<br />
Si c&#8217;est asynchrone, c&#8217;est pas bloquant. Si c&#8217;est pas bloquant, ça ne peut pas être synchrone.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: scaringella</title>
		<link>http://sametmax.com/droit-de-reponse-au-troll-js/#comment-21547</link>
		<dc:creator><![CDATA[scaringella]]></dc:creator>
		<pubDate>Wed, 19 Mar 2014 13:34:11 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=9812#comment-21547</guid>
		<description><![CDATA[Mouahahahah. J&#039;adore quand un spécialiste explique combien son outil est une grosse merde MAIS sic &quot;il faut vivre avec&quot; WTF! Le divorce c&#039;est pas pour les chiens!]]></description>
		<content:encoded><![CDATA[<p>Mouahahahah. J&#8217;adore quand un spécialiste explique combien son outil est une grosse merde MAIS sic &#8220;il faut vivre avec&#8221; WTF! Le divorce c&#8217;est pas pour les chiens!</p>
]]></content:encoded>
	</item>
</channel>
</rss>
